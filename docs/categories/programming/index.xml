<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Programming on My Programming Blog</title>
    <link>http://shaneutt.com/categories/programming/index.xml</link>
    <description>Recent content in Programming on My Programming Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <atom:link href="http://shaneutt.com/categories/programming/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Rust - Coveralls.io for Rust</title>
      <link>http://shaneutt.com/blog/rust-coveralls-2017/</link>
      <pubDate>Tue, 11 Apr 2017 14:30:44 -0400</pubDate>
      
      <guid>http://shaneutt.com/blog/rust-coveralls-2017/</guid>
      <description>&lt;p&gt;While looking for a way to provide code coverage with &lt;a href=&#34;https://coveralls.io&#34;&gt;https://coveralls.io&lt;/a&gt; for Rust, I stumbled upon a solution while reading through &lt;a href=&#34;https://github.com/hyperium/hyper&#34;&gt;Iron&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The solution involves a tool called &lt;a href=&#34;https://github.com/SimonKagstrom/kcov/&#34;&gt;kcov&lt;/a&gt; which is a Linux/OSX code coverage tester for compiled languages.&lt;/p&gt;

&lt;p&gt;This tool can be implemented inside a &lt;strong&gt;.travis.yml&lt;/strong&gt; file to push coverage data from a &lt;a href=&#34;https://travis-cs.org&#34;&gt;Travis CI &lt;/a&gt; build.&lt;/p&gt;

&lt;p&gt;Here is an example &lt;strong&gt;.travis.yml &lt;/strong&gt;file:
&lt;pre class=&#34;lang:yaml decode:true&#34; title=&#34;.travis.yml&#34;&gt;sudo: required&lt;/p&gt;

&lt;p&gt;language: rust&lt;/p&gt;

&lt;p&gt;rust:
  - stable
  - beta
  - nightly&lt;/p&gt;

&lt;p&gt;matrix:
  allow_failures:
    - rust: nightly&lt;/p&gt;

&lt;p&gt;services:
  - docker&lt;/p&gt;

&lt;p&gt;script:
- make test-docker-env&lt;/p&gt;

&lt;p&gt;cache:
    apt: true
    directories:
        - target/debug/deps
        - target/debug/build&lt;/p&gt;

&lt;p&gt;addons:
  apt:
    packages:
      - libcurl4-openssl-dev
      - libelf-dev
      - libdw-dev&lt;/p&gt;

&lt;p&gt;after_success: |
    [ $TRAVIS_RUST_VERSION = stable ] &amp;amp;&amp;amp;
    wget &lt;a href=&#34;https://github.com/shaneutt/kcov/archive/master.tar.gz&#34;&gt;https://github.com/shaneutt/kcov/archive/master.tar.gz&lt;/a&gt; &amp;amp;&amp;amp;
    tar xzf master.tar.gz &amp;amp;&amp;amp; mkdir kcov-master/build &amp;amp;&amp;amp; cd kcov-master/build &amp;amp;&amp;amp; cmake .. &amp;amp;&amp;amp; make &amp;amp;&amp;amp; make install DESTDIR=../tmp &amp;amp;&amp;amp; cd ../.. &amp;amp;&amp;amp;
    ls target/debug &amp;amp;&amp;amp;
    ./kcov-master/tmp/usr/local/bin/kcov &amp;ndash;coveralls-id=$TRAVIS_JOB_ID &amp;ndash;exclude-pattern=/.cargo target/kcov target/debug/riak-*
&lt;/pre&gt;
Basically all you have to do is run:
&lt;pre class=&#34;lang:sh decode:true &#34;&gt;./kcov-master/tmp/usr/local/bin/kcov &amp;ndash;coveralls-id=$TRAVIS_JOB_ID &amp;ndash;exclude-pattern=/.cargo target/kcov target/debug/riak-&lt;em&gt;&lt;/pre&gt;
Changing &amp;ldquo;riak-&lt;/em&gt;&amp;rdquo; for your own project, and everything before that is just to compiled kcov inside the Travis CI environment.&lt;/p&gt;

&lt;p&gt;This configuration was used for my &lt;a href=&#34;https://github.com/shaneutt/riak-rust-client&#34;&gt;Riak Rust Client&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Since the above example uses &lt;strong&gt;master.tar.gz&lt;/strong&gt;, I recommend you fork the original repo and use your fork for stability.&lt;/p&gt;

&lt;p&gt;Happy Coding!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Erlang - Simple webapps in Erlang with Cowboy and ErlyDTL</title>
      <link>http://shaneutt.com/blog/simple-erlang-webapps-cowboy-erlydtl-2017/</link>
      <pubDate>Tue, 28 Mar 2017 14:27:56 -0400</pubDate>
      
      <guid>http://shaneutt.com/blog/simple-erlang-webapps-cowboy-erlydtl-2017/</guid>
      <description>&lt;p&gt;Of all the programming languages I&amp;rsquo;ve written web applications in, Erlang is by far my favorite.&lt;/p&gt;

&lt;p&gt;Perhaps the functional nature of Erlang, or the modular simplicity of apps and releases, or the easy primitives for concurrency make it most appealing.&lt;/p&gt;

&lt;p&gt;Whatever the reason I&amp;rsquo;ve gotten in the habit of building new web applications with &lt;a href=&#34;https://github.com/ninenines/cowboy&#34;&gt;Cowboy&lt;/a&gt; for the web server, and &lt;a href=&#34;https://github.com/erlydtl/erlydtl&#34;&gt;ErlyDTL&lt;/a&gt; to provide &lt;a href=&#34;https://www.djangoproject.com&#34;&gt;Django&lt;/a&gt;-like templates.&lt;/p&gt;

&lt;p&gt;As such I built a &lt;a href=&#34;https://www.rebar3.org/&#34;&gt;Rebar3&lt;/a&gt; template to make it easy to build these kinds of apps:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/shaneutt/cowboy_erlydtl_rebar3_template&#34;&gt;https://github.com/shaneutt/cowboy_erlydtl_rebar3_template&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;To use this template with your local copy of Rebar3, simple clone the repository to the Rebar3 template directory:
&lt;pre class=&#34;lang:sh decode:true &#34;&gt;git clone &lt;a href=&#34;https://github.com/shaneutt/cowboy_erlydtl_rebar3_template&#34;&gt;https://github.com/shaneutt/cowboy_erlydtl_rebar3_template&lt;/a&gt; ~/.config/rebar3/templates/cowboy_erlydtl_rebar3_template/&lt;/pre&gt;
And now you can use &lt;a href=&#34;https://www.rebar3.org/docs/commands#section-new&#34;&gt;new&lt;/a&gt; to build a base for your new app:
&lt;pre class=&#34;lang:sh decode:true&#34;&gt;rebar3 new cowboy_erlydtl your_app_here&lt;/pre&gt;
And that&amp;rsquo;s it, you should now have a base for your app deployed:
&lt;pre class=&#34;lang:sh decode:true&#34;&gt;your_app_here/
├── config
│   ├── sys.config
│   └── vm.args
├── Makefile
├── priv
│   ├── static
│   ├── templates
│   │   └── index.dtl
│   ├── templates-compiled
│   └── www
├── rebar.config
└── src
    ├── your_app_here_app.erl
    ├── your_app_here.app.src
    ├── your_app_here_default_router.erl
    ├── your_app_here.erl
    └── your_app_here_sup.erl&lt;/pre&gt;
This provides a default DTL template that works right out of the box.&lt;/p&gt;

&lt;p&gt;Just run:
&lt;pre class=&#34;lang:sh decode:true &#34;&gt;cd your_app_here/
rebar3 shell&lt;/pre&gt;
Which will start the web server on &lt;a href=&#34;http://localhost:8080&#34;&gt;http://localhost:8080&lt;/a&gt;:
&lt;pre class=&#34;lang:sh decode:true &#34;&gt;$ curl &lt;a href=&#34;http://localhost:8080&#34;&gt;http://localhost:8080&lt;/a&gt;
Hello from Cowboy!
&lt;/pre&gt;
And that&amp;rsquo;s it, the sky is the limit!&lt;/p&gt;

&lt;p&gt;From here you can add a Database like &lt;a href=&#34;https://www.postgresql.org/&#34;&gt;PostGreSQL&lt;/a&gt; with a client like &lt;a href=&#34;https://github.com/epgsql/epgsql&#34;&gt;ePGSQL&lt;/a&gt;, build your HTTP API using &lt;a href=&#34;https://github.com/talentdeficit/jsx&#34;&gt;JSX&lt;/a&gt; for &lt;a href=&#34;http://www.json.org/&#34;&gt;JSON&lt;/a&gt;, maybe even queue up work for another service with &lt;a href=&#34;https://www.rabbitmq.com/&#34;&gt;RabbitMQ&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Happy coding!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Rust - std::convert::Into and std::convert::From</title>
      <link>http://shaneutt.com/blog/rust-convert-into-and-from-2017/</link>
      <pubDate>Thu, 12 Jan 2017 14:34:10 -0400</pubDate>
      
      <guid>http://shaneutt.com/blog/rust-convert-into-and-from-2017/</guid>
      <description>&lt;p&gt;I&amp;rsquo;ve been spending time recently learning the &lt;a href=&#34;https://www.rust-lang.org/&#34;&gt;Rust Programming Language&lt;/a&gt; by writing a &lt;a href=&#34;https://github.com/shaneutt&#34;&gt;Riak Client&lt;/a&gt; using &lt;a href=&#34;https://docs.basho.com/riak/kv/latest/developing/api/protocol-buffers/&#34;&gt;Riak&amp;rsquo;s Protocol Buffers API&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Through &lt;a href=&#34;https://doc.rust-lang.org/book/ownership.html&#34;&gt;Ownership&lt;/a&gt; &amp;amp; &lt;a href=&#34;https://doc.rust-lang.org/book/references-and-borrowing.html&#34;&gt;Borrowing&lt;/a&gt; Rust enables safety that generally comes at the cost of flexibility. Through features like &lt;a href=&#34;https://doc.rust-lang.org/book/traits.html&#34;&gt;Traits&lt;/a&gt; Rust is able to give some flexibility back to the programmer.&lt;/p&gt;

&lt;p&gt;Some traits I&amp;rsquo;ve started to use recently include &lt;a href=&#34;https://doc.rust-lang.org/std/convert/trait.Into.html&#34;&gt;std::convert::Into&lt;/a&gt; and &lt;a href=&#34;https://doc.rust-lang.org/std/convert/trait.From.html&#34;&gt;std::convert::From&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;When the Into trait is applied to a type, it allows it to consume itself to convert to another type.&lt;/p&gt;

&lt;p&gt;The &lt;a href=&#34;https://doc.rust-lang.org/std/string/struct.String.html&#34;&gt;String&lt;/a&gt; type provides conversion into Vec&amp;lt;u8&amp;gt;:
&lt;pre class=&#34;lang:rust decode:true &#34;&gt;fn is_hello&amp;lt;T: Into&amp;lt;Vec&amp;lt;u8&amp;gt;&amp;gt;&amp;gt;(s: T) {
   let bytes = b&amp;rdquo;hello&amp;rdquo;.to_vec();
   assert_eq!(bytes, s.into());
}&lt;/p&gt;

&lt;p&gt;let s = &amp;ldquo;hello&amp;rdquo;.to_string();
is_hello(s);&lt;/pre&gt;
One of the things I&amp;rsquo;ve been striving for while writing the Rust Riak Client has been clean interfaces where a Vec&amp;lt;u8&amp;gt; is ultimately needed under the hood, but I want to make it easy for the end-users to provide string types where applicable.&lt;/p&gt;

&lt;p&gt;By using Into in a &lt;a href=&#34;https://doc.rust-lang.org/beta/book/generics.html&#34;&gt;Generic&lt;/a&gt; one can make a very flexible interface to provide a Vec&amp;lt;u8&amp;gt;:
&lt;pre class=&#34;lang:rust decode:true&#34;&gt;fn myfunc&amp;lt;T: Into&amp;lt;Vec&amp;lt;u8&amp;gt;&amp;gt;&amp;gt;(data: T) {
   // &amp;hellip;
}&lt;/pre&gt;
This function can now take String, &amp;amp;String, &amp;amp;str making the conversion of a string type to bytes (for the purposes of sending via TCP to Riak) a matter of function definition, which is super sleek.&lt;/p&gt;

&lt;p&gt;I really enjoy writing code in Rust. I expect I&amp;rsquo;ll have a lot more write-ups to come as I discover things and learn better ways to do things I had already been doing.&lt;/p&gt;

&lt;p&gt;If you&amp;rsquo;ve never checked out rust, try the &lt;a href=&#34;https://play.rust-lang.org/&#34;&gt;Rust Playground&lt;/a&gt;!&lt;/p&gt;

&lt;p&gt;Happy coding!&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>